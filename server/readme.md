## m_base_node
&emsp;&emsp;此为节点基类，包含一条`m_thread`线程，以及若干纯虚函数来**操作/配合**此条线程。

&emsp;
## m_group_node
&emsp;&emsp;此为组节点，当有客户端连接时，会将此连接分配至"较为合适"的组节点，若此线程未启动，则此组节点线程启动。而当监听连接全部断开后，组节点会停止工作线程。也就是说在组节点没有监听对象时，工作线程是关闭的。<br>
&emsp;&emsp;此节点主要的功能就是处理客户端发来的业务报文，包括数据上传、数据请求等。报文的多路复用I/O通过`epoll`来实现。

&emsp;
## m_task_node
&emsp;&emsp;此为任务节点，每一个组节点均含有一个任务节点，其负责所属节点的发送任务。<br>
&emsp;&emsp;其所属节点通过调用任务节点方法来向发送队列中添加新的发送任务，从而实现报文的异步发送。

&emsp;
## m_client_node
&emsp;&emsp;此类为客户端节点类。<br>
&emsp;&emsp;每一个socket连接后，都会创建一个`m_client_node`来**储存/管理**这个连接。<br>
&emsp;&emsp;其中主要储存了：此连接的心跳计时与此连接的二级缓冲区。作用点分别为保活机制、以及对半包粘包问题的处理。

&emsp;
## m_db_mgr
&emsp;&emsp;此类是对public部分`m_db`类的二次封装，主要是为了管理`pi_net`数据库。
&emsp;&emsp;其主要功能是数据库的反序列化和序列化。而二次封装的内容为若干sql语句以及若干数据库管理方法，包括数据库的增删改等。

&emsp;
## m_server
&emsp;&emsp;此类为服务端类，其中含有一个登录节点和若干组节点，而登录节点与组节点均各自有属于自己的任务节点，从而来实现管理分流和报文的异步收发。主线程则是监听新连接以及处理数据库操作任务。<br>
**结构**:
* 主线程 -> start若干个组节点 / epoll监听新连接 
* 子线程1/2 -> m_group_node组节点 / m_task_node任务节点 -> 前者负责业务报文的处理，后者负责处理结果的发送
* 子线程3/4 -> m_group_node组节点 / m_task_node任务节点 -> 前者负责业务报文的处理，后者负责处理结果的发送
* 子线程5/6 -> m_group_node组节点 / m_task_node任务节点 -> ...
* ... (每一个组均有其专属的任务节点)